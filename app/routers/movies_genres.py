from typing import List
from datetime import datetime
from firebase_admin.db import Reference
from database.database import get_database
from firebase_admin.exceptions import FirebaseError
from fastapi import APIRouter, status, Depends, HTTPException
from schemas.movies_genres import MovieGenre, MovieGenrePost, MovieGenreUpdate, MovieGenreDelete, MovieGenreResponse

router = APIRouter()


@router.get('/movies_genres/{movie_genre_id}', response_model=MovieGenreResponse, status_code=status.HTTP_200_OK)
async def get_movie_genre(movie_genre_id: str, db: Reference = Depends(get_database)) -> MovieGenreResponse:
    """

    Retrieve a specific movie_genre from the database by its ID.

    Parameters:
        movie_genre_id (str): The ID of the movie_genre to retrieve.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        movie_genre (MovieGenreResponse): The movie_genre data, retrieved from the database and modeled as a MovieGenreResponse object.

    """
    try:
        # Construct a reference to the specific movie_genre in Firebase
        reference = db.child('MovieGenres').child(movie_genre_id)

        # Use the reference to get the movie_genre data
        movie_genre = reference.get()
    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to fetch data: {error}")

    # If the movie_genre data is None, that means the movie_genre was not found
    if movie_genre is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"MovieGenre ID {movie_genre_id} was not found.")

    # If the movie_genre data is not None, we add the movie_genre_id to the dictionary
    else:
        movie_genre['movie_genre_id'] = movie_genre_id

    # Convert the dictionary to a MovieGenreResponse object
    movie_genre = MovieGenreResponse(**movie_genre)

    return movie_genre


@router.get('/movies_genres', response_model=List[MovieGenreResponse], status_code=status.HTTP_200_OK)
async def get_movies_genres(db: Reference = Depends(get_database)):
    """

    Retrieve all movies_genres from the database.

    Parameters:
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        movies_genres (List[MovieGenreResponse]): A list of movie_genre data, retrieved from the database.

    """

    try:
        # Get all movies_genres from Firebase
        movies_genres = db.child('MovieGenres').get()
    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to fetch data: {error}")

    # Create a list of dictionaries, adding the key as 'movie_genre_id' to each dictionary
    # Here, key is the unique id generated by Firebase, and value is the corresponding movie_genre data
    movies_genres = [{'movie_genre_id': key, **value} for key, value in movies_genres.items() if value]

    # Convert each dictionary in movies_genres_data to a MovieGenreResponse object
    # We're using a generator expression here instead of a list comprehension for better performance
    # A generator expression doesn't construct the whole list in memory, it generates each item on-the-fly
    movies_genres = list(MovieGenreResponse(**movie_genre) for movie_genre in movies_genres)

    return movies_genres


@router.post('/movies_genres', status_code=status.HTTP_201_CREATED, response_model=MovieGenreResponse)
async def post_movie_genre(movie_genre: MovieGenrePost, db: Reference = Depends(get_database)):
    """
    Create a new movie_genre in the database.

    Parameters:
        movie_genre (MovieGenrePost): The movie_genre data to be saved, parsed from the request body.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        movie_genre (MovieGenrePost): The created movie_genre data, retrieved from the database.

    """
    # Convert the movie_genre data to a dict, ready for Firebase
    movie_genre = movie_genre.dict()

    # Create the 'created_at' field with reference in UTC time
    movie_genre['created_at'] = datetime.utcnow().isoformat()

    try:
        # Create a new reference in the 'MovieGenres' node, with a unique key
        reference = db.child('MovieGenres').push()

        # Set the movie_genre data at the new reference
        reference.set(movie_genre)

        # Retrieve the created movie_genre data using the new reference
        # We do this to include any server-side transformations or additions (like the created time) in the response
        movie_genre = reference.get()

        # Adding the primary key
        movie_genre['movie_genre_id'] = reference.key

        # Return the created movie_genre data, along with a 201 status code
        return MovieGenreResponse(**movie_genre)

    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, return a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to push data: {error}")


@router.delete('/movies_genres/{movie_genre_id}', response_model=MovieGenreResponse, status_code=status.HTTP_200_OK)
async def delete_movie_genre(movie_genre_id: str, db: Reference = Depends(get_database)) -> MovieGenreResponse:

    """

    Deletes the movie_genre from database given it's ID

    Parameters:
        movie_genre_id (str): The ID of the movie_genre to retrieve.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        movie_genre (MovieGenreResponse): The movie_genre data, deleted from the database and modeled as a MovieGenreResponse object.

    """
    try:
        # Construct a reference to the specific movie_genre in Firebase
        reference = db.child('MovieGenres').child(movie_genre_id)

        # Use the reference to get the movie_genre data
        movie_genre = reference.get()

        if movie_genre is not None:
            # Deleting the desired data
            reference.delete()

    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to fetch data: {error}")

    # If the movie_genre data is None, that means the movie_genre was not found
    if movie_genre is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"MovieGenre ID {movie_genre_id} was not found.")

    # If the movie_genre data is not None, we add the movie_genre_id to the dictionary
    else:
        movie_genre['movie_genre_id'] = movie_genre_id

    # Convert the dictionary to a MovieGenreResponse object
    movie_genre = MovieGenreResponse(**movie_genre)

    return movie_genre


@router.put('/movies_genres', status_code=status.HTTP_200_OK, response_model=MovieGenreResponse)
async def put_movie_genre(movie_genre: MovieGenreUpdate, db: Reference = Depends(get_database)) -> MovieGenreResponse:
    """
    Updates a movie_genre in the database.

    Parameters:
        movie_genre (MovieGenreUpdate): The movie_genre data to be updated, parsed from the request body.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        movie_genre (MovieGenreResponse): The updated movie_genre data, retrieved from the database.
    """

    # Convert the MovieGenreUpdate Pydantic model to a dict
    movie_genre = movie_genre.dict()

    # Extract movie_genre_id from the data and remove it from the dict
    movie_genre_id = movie_genre.pop('movie_genre_id')

    try:
        # Create a reference to the movie_genre in the 'MovieGenres' node in Firebase
        reference = db.child('MovieGenres').child(movie_genre_id)

        # Get the current movie_genre data
        old_movie_genre = reference.get()

        # If the movie_genre doesn't exist, raise a 404 Not Found exception
        if old_movie_genre is None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                                detail=f"MovieGenre ID {movie_genre_id} was not found.")

        # If the movie_genre exists, keep the created_at timestamp unchanged
        movie_genre['created_at'] = old_movie_genre['created_at']

        # Update the movie_genre data at the reference
        reference.update(movie_genre)

        # Retrieve the updated movie_genre data from Firebase
        # This includes any server-side transformations or additions
        updated_movie_genre = reference.get()

        # Add the movie_genre_id to the movie_genre data
        updated_movie_genre['movie_genre_id'] = movie_genre_id

        # Convert the dict to a MovieGenreResponse Pydantic model and return it
        return MovieGenreResponse(**updated_movie_genre)

    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 Internal Server Error
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to update the movie_genre: {error}")
