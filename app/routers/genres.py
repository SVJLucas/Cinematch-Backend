from typing import List
from datetime import datetime
from firebase_admin.db import Reference
from database.database import get_database
from firebase_admin.exceptions import FirebaseError
from fastapi import APIRouter, status, Depends, HTTPException
from schemas.genres import Genre, GenrePost, GenreUpdate, GenreDelete, GenreResponse

router = APIRouter()


@router.get('/genres/{genre_id}', response_model=GenreResponse, status_code=status.HTTP_200_OK)
async def get_genre(genre_id: str, db: Reference = Depends(get_database)) -> GenreResponse:
    """

    Retrieve a specific genre from the database by its ID.

    Parameters:
        genre_id (str): The ID of the genre to retrieve.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        genre (GenreResponse): The genre data, retrieved from the database and modeled as a GenreResponse object.

    """
    try:
        # Construct a reference to the specific genre in Firebase
        reference = db.child('Genres').child(genre_id)

        # Use the reference to get the genre data
        genre = reference.get()
    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to fetch data: {error}")

    # If the genre data is None, that means the genre was not found
    if genre is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Genre ID {genre_id} was not found.")

    # If the genre data is not None, we add the genre_id to the dictionary
    else:
        genre['genre_id'] = genre_id

    # Convert the dictionary to a GenreResponse object
    genre = GenreResponse(**genre)

    return genre


@router.get('/genres', response_model=List[GenreResponse], status_code=status.HTTP_200_OK)
async def get_genres(db: Reference = Depends(get_database)):
    """

    Retrieve all genres from the database.

    Parameters:
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        genres (List[GenreResponse]): A list of genre data, retrieved from the database.

    """

    try:
        # Get all genres from Firebase
        genres = db.child('Genres').get()
    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to fetch data: {error}")

    # Create a list of dictionaries, adding the key as 'genre_id' to each dictionary
    # Here, key is the unique id generated by Firebase, and value is the corresponding genre data
    genres = [{'genre_id': key, **value} for key, value in genres.items() if value]

    # Convert each dictionary in genres_data to a GenreResponse object
    # We're using a generator expression here instead of a list comprehension for better performance
    # A generator expression doesn't construct the whole list in memory, it generates each item on-the-fly
    genres = list(GenreResponse(**genre) for genre in genres)

    return genres


@router.post('/genres', status_code=status.HTTP_201_CREATED, response_model=GenreResponse)
async def post_genre(genre: GenrePost, db: Reference = Depends(get_database)):
    """
    Create a new genre in the database.

    Parameters:
        genre (GenrePost): The genre data to be saved, parsed from the request body.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        genre (GenrePost): The created genre data, retrieved from the database.

    """
    # Convert the genre data to a dict, ready for Firebase
    genre = genre.dict()

    # Create the 'created_at' field with reference in UTC time
    genre['created_at'] = datetime.utcnow().isoformat()

    try:
        # Create a new reference in the 'Genres' node, with a unique key
        reference = db.child('Genres').push()

        # Set the genre data at the new reference
        reference.set(genre)

        # Retrieve the created genre data using the new reference
        # We do this to include any server-side transformations or additions (like the created time) in the response
        genre = reference.get()

        # Adding the primary key
        genre['genre_id'] = reference.key

        # Return the created genre data, along with a 201 status code
        return GenreResponse(**genre)

    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, return a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to push data: {error}")


@router.delete('/genres/{genre_id}', response_model=GenreResponse, status_code=status.HTTP_200_OK)
async def delete_genre(genre_id: str, db: Reference = Depends(get_database)) -> GenreResponse:

    """

    Deletes the genre from database given it's ID

    Parameters:
        genre_id (str): The ID of the genre to retrieve.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        genre (GenreResponse): The genre data, deleted from the database and modeled as a GenreResponse object.

    """
    try:
        # Construct a reference to the specific genre in Firebase
        reference = db.child('Genres').child(genre_id)

        # Use the reference to get the genre data
        genre = reference.get()

        if genre is not None:
            # Deleting the desired data
            reference.delete()

    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 status code with a helpful message
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to fetch data: {error}")

    # If the genre data is None, that means the genre was not found
    if genre is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Genre ID {genre_id} was not found.")

    # If the genre data is not None, we add the genre_id to the dictionary
    else:
        genre['genre_id'] = genre_id

    # Convert the dictionary to a GenreResponse object
    genre = GenreResponse(**genre)

    return genre


@router.put('/genres', status_code=status.HTTP_200_OK, response_model=GenreResponse)
async def put_genre(genre: GenreUpdate, db: Reference = Depends(get_database)) -> GenreResponse:
    """
    Updates a genre in the database.

    Parameters:
        genre (GenreUpdate): The genre data to be updated, parsed from the request body.
        db (Reference): A reference to the Firebase database, injected by FastAPI's dependency injection.

    Returns:
        genre (GenreResponse): The updated genre data, retrieved from the database.
    """

    # Convert the GenreUpdate Pydantic model to a dict
    genre = genre.dict()

    # Extract genre_id from the data and remove it from the dict
    genre_id = genre.pop('genre_id')

    try:
        # Create a reference to the genre in the 'Genres' node in Firebase
        reference = db.child('Genres').child(genre_id)

        # Get the current genre data
        old_genre = reference.get()

        # If the genre doesn't exist, raise a 404 Not Found exception
        if old_genre is None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                                detail=f"Genre ID {genre_id} was not found.")

        # If the genre exists, keep the created_at timestamp unchanged
        genre['created_at'] = old_genre['created_at']

        # Update the genre data at the reference
        reference.update(genre)

        # Retrieve the updated genre data from Firebase
        # This includes any server-side transformations or additions
        updated_genre = reference.get()

        # Add the genre_id to the genre data
        updated_genre['genre_id'] = genre_id

        # Convert the dict to a GenreResponse Pydantic model and return it
        return GenreResponse(**updated_genre)

    except FirebaseError as error:
        # If an error occurred while interacting with Firebase, raise a 500 Internal Server Error
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"An error occurred while trying to update the genre: {error}")
